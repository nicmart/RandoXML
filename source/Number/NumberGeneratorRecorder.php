<?php
namespace nicmart\Random\Number;

use nicmart\Random\Number\NumberGenerator;
use nicmart\Random\Number\CyclicNumberGenerator;

/**
 * A Decorator class built around another Generator that can record the
 * returns value of that generator.
 */

class NumberGeneratorRecorder implements NumberGenerator
{
    /**
     * State constants
     */
    const STATE_STOP = 0;
    const STATE_RECORDING = 1;
    const STATE_PLAYING = 2;

    /**
     * @var NumberGenerator
     */
    private $recordedGenerator;

    /**
     * @var CyclicNumberGenerator
     */
    private $playingGenerator;

    /**
     * This is a pointer to one of the previous generator, and the
     * state determines which is pointed
     * @var NumberGenerator
     */
    private $currentGenerator;

    /**
     * @var array
     */
    private $recording;

    /**
     * @var int the current recorder state
     */
    private $state;

    /**
     * @param NumberGenerator $generator
     */
    public function __construct(NumberGenerator $generator, CyclicNumberGenerator $cyclicGenerator = null)
    {
        if(!isset($cyclicGenerator))
                {
                    $cyclicGenerator = new CyclicNumberGenerator();
                }

        $this->recordedGenerator = $this->currentGenerator = $generator;
        $this->playingGenerator = $cyclicGenerator;

        $this->state = static::STATE_RECORDING;
    }


    /**
     * Returns an integer between $min and $max
     *
     * @param int $min
     * @param int $max
     * @return mixed
     */
    public function rand($min, $max)
    {
        $n = $this->currentGenerator->rand($min, $max);

        if($this->state === static::STATE_RECORDING)
                {
                    $this->recording[] = $n;
                }

        return $n;
    }

    /**
     * Returns the max integer supported by the generator
     *
     * @return int
     */
    public function randMax()
    {
        return $this->recordedGenerator->randMax();
    }


    /**
     * Put the recorder in playing state.
     * The generator will cyclicly return the recorded numbers
     *
     * @return NumberGeneratorRecorder The current instance
     */
    public function play()
    {
        $this->state = static::STATE_PLAYING;
        $this->currentGenerator = $this->playingGenerator;
        $this->playingGenerator->setSequence($this->getRecording());

        return $this;
    }

    /**
     * Put the recorder in recording state.
     *
     * @return NumberGeneratorRecorder The current instance
     */
    public function record()
    {
        $this->state = static::STATE_RECORDING;
        $this->currentGenerator = $this->recordedGenerator;

        return $this;
    }

    /**
     * Stop the recorder. The recorder will still return the numbers generated by the
     * decorated generator, but it will not record that numbers.
     *
     * @return NumberGeneratorRecorder The current instance
     */
    public function stop()
    {
        $this->state = static::STATE_STOP;
        $this->currentGenerator = $this->recordedGenerator;

        return $this;
    }

    /**
     * Get the recorded sequence
     *
     * @return array
     */
    public function getRecording()
    {
        return $this->recording;
    }

    /**
     * @return NumberGenerator
     */
    public function getRecordedGenerator()
    {
        return $this->recordedGenerator;
    }

}
